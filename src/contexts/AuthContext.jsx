import React, { createContext, useContext, useState, useEffect } from 'react';
import { 
  signInWithPopup, 
  signOut, 
  onAuthStateChanged,
  GoogleAuthProvider,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  updateProfile
} from 'firebase/auth';
import { 
  doc, 
  getDoc, 
  setDoc, 
  updateDoc, 
  deleteDoc,
  collection, 
  query, 
  where, 
  getDocs,
  serverTimestamp,
  onSnapshot
} from 'firebase/firestore';
import { auth, googleProvider, db } from '../firebase/config';
import { ADMIN_EMAILS, isAdminEmail } from '../config/adminEmails';
import { toast } from 'react-toastify';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth deve ser usado dentro de um AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [userId, setUserId] = useState(null);
  const [isAuthorized, setIsAuthorized] = useState(false);
  const [userEmail, setUserEmail] = useState(null);
  const [pendingAuthorization, setPendingAuthorization] = useState(false);
  const [userProfile, setUserProfile] = useState(null);
  const [authMode, setAuthMode] = useState('login'); // 'login', 'register', 'google'

   // Verificar se email j√° existe com outro provider
   const checkEmailExists = async (email) => {
     try {
       const q = query(collection(db, 'users'), where('email', '==', email));
       const querySnapshot = await getDocs(q);
       return querySnapshot.docs.length > 0;
     } catch (error) {
       console.error('Erro ao verificar email existente:', error);
       return false;
     }
   };

   // Verificar autoriza√ß√£o do usu√°rio no Firestore
   const checkUserAuthorization = async (userId, email) => {
     try {
       const userDoc = await getDoc(doc(db, 'users', userId));
       const isAdmin = isAdminEmail(email);
       
       if (userDoc.exists()) {
         const userData = userDoc.data();
         
         // Se for admin e n√£o estiver autorizado, autorizar automaticamente
         if (isAdmin && !userData.isAuthorized) {
           await updateDoc(doc(db, 'users', userId), {
             isAuthorized: true,
             pendingAuthorization: false,
             authorizedAt: serverTimestamp(),
             authorizedBy: 'system'
           });
           
           return {
             isAuthorized: true,
             profile: { ...userData, isAuthorized: true, pendingAuthorization: false },
             pendingAuthorization: false
           };
         }
         
         return {
           isAuthorized: userData.isAuthorized || false,
           profile: userData,
           pendingAuthorization: userData.pendingAuthorization || false
         };
       } else {
         // Verificar se email j√° existe com outro provider
         const emailExists = await checkEmailExists(email);
         if (emailExists) {
           throw new Error('Este email j√° est√° sendo usado com outro m√©todo de login. Use o m√©todo original ou entre em contato com o administrador.');
         }

         // Criar perfil do usu√°rio se n√£o existir
         const newUserProfile = {
           email: email,
           displayName: user?.displayName || '',
           photoURL: user?.photoURL || '',
           isAuthorized: isAdmin, // Administradores s√£o automaticamente autorizados
           pendingAuthorization: !isAdmin, // Apenas n√£o-admins ficam pendentes
           createdAt: serverTimestamp(),
           lastLogin: serverTimestamp(),
           ...(isAdmin && {
             authorizedAt: serverTimestamp(),
             authorizedBy: 'system'
           })
         };
         
         await setDoc(doc(db, 'users', userId), newUserProfile);
         
         return {
           isAuthorized: isAdmin,
           profile: newUserProfile,
           pendingAuthorization: !isAdmin
         };
       }
     } catch (error) {
       console.error('Erro ao verificar autoriza√ß√£o:', error);
       return {
         isAuthorized: false,
         profile: null,
         pendingAuthorization: false
       };
     }
   };

  // Cadastro com email/senha
  const registerWithEmail = async (email, password, displayName) => {
    try {
      setLoading(true);
      
      if (!auth) {
        throw new Error('Firebase Auth n√£o est√° configurado corretamente');
      }
      
      const result = await createUserWithEmailAndPassword(auth, email, password);
      
      // Atualizar perfil do usu√°rio
      await updateProfile(result.user, {
        displayName: displayName
      });
      
      const userId = result.user.uid;
      
      // Verificar autoriza√ß√£o no Firestore
      const authStatus = await checkUserAuthorization(userId, email);
      
      setUserEmail(email);
      setUserProfile(authStatus.profile);
      setPendingAuthorization(authStatus.pendingAuthorization);
      
      if (authStatus.isAuthorized) {
        setIsAuthorized(true);
        toast.success(`Bem-vindo, ${displayName}!`);
        return result.user;
      } else if (authStatus.pendingAuthorization) {
        setIsAuthorized(false);
        toast.info('Sua conta foi criada e est√° aguardando autoriza√ß√£o do administrador.');
        return null;
      } else {
        setIsAuthorized(false);
        toast.info('Sua conta foi criada e est√° aguardando autoriza√ß√£o do administrador.');
        return null;
      }
    } catch (error) {
      console.error('Erro no cadastro:', error);
      
      // Tratamento espec√≠fico de erros
      if (error.code === 'auth/email-already-in-use') {
        toast.error('Este email j√° est√° sendo usado por outra conta.');
      } else if (error.code === 'auth/weak-password') {
        toast.error('A senha deve ter pelo menos 6 caracteres.');
      } else if (error.code === 'auth/invalid-email') {
        toast.error('Email inv√°lido.');
      } else {
        toast.error(`Erro ao criar conta: ${error.message}`);
      }
      
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // Login com email/senha
  const loginWithEmail = async (email, password) => {
    try {
      setLoading(true);
      
      if (!auth) {
        throw new Error('Firebase Auth n√£o est√° configurado corretamente');
      }
      
      const result = await signInWithEmailAndPassword(auth, email, password);
      const userId = result.user.uid;
      
      // Verificar autoriza√ß√£o no Firestore
      const authStatus = await checkUserAuthorization(userId, email);
      
      setUserEmail(email);
      setUserProfile(authStatus.profile);
      setPendingAuthorization(authStatus.pendingAuthorization);
      
       if (authStatus.isAuthorized) {
         setIsAuthorized(true);
         toast.success(`Bem-vindo, ${result.user.displayName || email}!`);
         return result.user;
       } else if (authStatus.pendingAuthorization) {
         setIsAuthorized(false);
         toast.info('Sua conta est√° aguardando autoriza√ß√£o do administrador.');
         return null;
       } else {
         setIsAuthorized(false);
         // Solicitar nova autoriza√ß√£o em vez de negar acesso
         await requestNewAuthorization(userId, email);
         toast.info('üìù Nova solicita√ß√£o de autoriza√ß√£o enviada. Aguarde a aprova√ß√£o do administrador.');
         return null;
       }
    } catch (error) {
      console.error('Erro no login:', error);
      
      // Tratamento espec√≠fico de erros
      if (error.code === 'auth/user-not-found') {
        toast.error('‚ùå Email n√£o encontrado. Verifique o email ou crie uma conta.');
      } else if (error.code === 'auth/wrong-password') {
        toast.error('‚ùå Senha incorreta. Tente novamente.');
      } else if (error.code === 'auth/invalid-email') {
        toast.error('‚ùå Email inv√°lido. Verifique o formato do email.');
      } else if (error.code === 'auth/too-many-requests') {
        toast.error('‚ö†Ô∏è Muitas tentativas. Aguarde alguns minutos antes de tentar novamente.');
      } else if (error.code === 'auth/invalid-credential') {
        toast.error('‚ùå Email ou senha incorretos. Verifique suas credenciais.');
      } else {
        toast.error(`‚ùå Erro ao fazer login: ${error.message}`);
      }
      
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // Login com Google
  const loginWithGoogle = async () => {
    try {
      setLoading(true);
      
      // Verificar se o auth est√° dispon√≠vel
      if (!auth) {
        throw new Error('Firebase Auth n√£o est√° configurado corretamente');
      }
      
      const result = await signInWithPopup(auth, googleProvider);
      const credential = GoogleAuthProvider.credentialFromResult(result);
      const token = credential?.accessToken;
      
      const email = result.user.email;
      const userId = result.user.uid;
      
      // Verificar autoriza√ß√£o no Firestore
      const authStatus = await checkUserAuthorization(userId, email);
      
      setUserEmail(email);
      setUserProfile(authStatus.profile);
      setPendingAuthorization(authStatus.pendingAuthorization);
      
       if (authStatus.isAuthorized) {
         setIsAuthorized(true);
         toast.success(`Bem-vindo, ${result.user.displayName}!`);
         return result.user;
       } else if (authStatus.pendingAuthorization) {
         setIsAuthorized(false);
         toast.info('Sua conta est√° aguardando autoriza√ß√£o. Entre em contato com o administrador.');
         return null;
       } else {
         setIsAuthorized(false);
         // Solicitar nova autoriza√ß√£o em vez de negar acesso
         await requestNewAuthorization(userId, email);
         toast.info('üìù Nova solicita√ß√£o de autoriza√ß√£o enviada. Aguarde a aprova√ß√£o do administrador.');
         return null;
       }
    } catch (error) {
      console.error('Erro no login:', error);
      
      // Tratamento espec√≠fico de erros
      if (error.code === 'auth/configuration-not-found') {
        toast.error('Firebase Authentication n√£o est√° configurado. Verifique o Firebase Console.');
      } else if (error.code === 'auth/popup-closed-by-user') {
        toast.info('Login cancelado pelo usu√°rio');
      } else if (error.code === 'auth/popup-blocked') {
        toast.error('Popup bloqueado pelo navegador. Permita popups para este site.');
      } else if (error.code === 'auth/unauthorized-domain') {
        toast.error('Dom√≠nio n√£o autorizado. Verifique as configura√ß√µes do Firebase.');
      } else {
        toast.error(`Erro ao fazer login: ${error.message}`);
      }
      
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // Logout
  const logout = async () => {
    try {
      await signOut(auth);
      setIsAuthorized(false);
      setUserEmail(null);
      setPendingAuthorization(false);
      setUserProfile(null);
      toast.success('Logout realizado com sucesso!');
    } catch (error) {
      console.error('Erro no logout:', error);
      toast.error('Erro ao fazer logout.');
    }
  };

   // Fun√ß√£o para autorizar usu√°rio (apenas para administradores)
   const authorizeUser = async (userId, isAuthorized = true) => {
     try {
       // Buscar dados do usu√°rio para verificar se √© admin
       const userDoc = await getDoc(doc(db, 'users', userId));
       if (userDoc.exists()) {
         const userData = userDoc.data();
         
         // Verificar se √© admin - n√£o permitir desautorizar
         if (isAdminEmail(userData.email) && !isAuthorized) {
           toast.error('‚ùå N√£o √© poss√≠vel desautorizar um administrador!');
           return false;
         }
       }

       await updateDoc(doc(db, 'users', userId), {
         isAuthorized: isAuthorized,
         pendingAuthorization: false,
         authorizedAt: serverTimestamp(),
         authorizedBy: user?.uid
       });
       
       // Se for o pr√≥prio usu√°rio sendo autorizado, atualizar estado local
       if (userId === user?.uid) {
         setIsAuthorized(isAuthorized);
         setPendingAuthorization(false);
       }
       
       toast.success(`Usu√°rio ${isAuthorized ? 'autorizado' : 'desautorizado'} com sucesso!`);
       return true;
     } catch (error) {
       console.error('Erro ao autorizar usu√°rio:', error);
       toast.error('Erro ao autorizar usu√°rio.');
       return false;
     }
   };

  // Fun√ß√£o para obter TODOS os usu√°rios
  const getAllUsers = async () => {
    try {
      const q = query(collection(db, 'users'));
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
    } catch (error) {
      console.error('Erro ao buscar todos os usu√°rios:', error);
      return [];
    }
  };

  // Fun√ß√£o para obter lista de usu√°rios pendentes
  const getPendingUsers = async () => {
    try {
      const allUsers = await getAllUsers();
      return allUsers.filter(user => user.pendingAuthorization === true);
    } catch (error) {
      console.error('Erro ao buscar usu√°rios pendentes:', error);
      return [];
    }
  };

  // Fun√ß√£o para obter lista de usu√°rios autorizados
  const getAuthorizedUsers = async () => {
    try {
      const allUsers = await getAllUsers();
      return allUsers.filter(user => user.isAuthorized === true);
    } catch (error) {
      console.error('Erro ao buscar usu√°rios autorizados:', error);
      return [];
    }
  };

   // Fun√ß√£o para obter provedores de um usu√°rio espec√≠fico
   const getUserProviders = async (userId) => {
     try {
       const q = query(
         collection(db, 'provedores'),
         where('userId', '==', userId)
       );
       const querySnapshot = await getDocs(q);
       return querySnapshot.docs.map(doc => ({
         id: doc.id,
         ...doc.data()
       }));
     } catch (error) {
       console.error('Erro ao buscar provedores do usu√°rio:', error);
       return [];
     }
   };

   // Fun√ß√£o para obter TODOS os provedores do sistema
   const getAllProviders = async () => {
     try {
       const q = query(collection(db, 'provedores'));
       const querySnapshot = await getDocs(q);
       return querySnapshot.docs.map(doc => ({
         id: doc.id,
         ...doc.data()
       }));
     } catch (error) {
       console.error('Erro ao buscar todos os provedores:', error);
       return [];
     }
   };

   // Fun√ß√£o para solicitar nova autoriza√ß√£o
   const requestNewAuthorization = async (userId, email) => {
     try {
       await updateDoc(doc(db, 'users', userId), {
         isAuthorized: false,
         pendingAuthorization: true,
         requestedAt: serverTimestamp(),
         requestCount: (userProfile?.requestCount || 0) + 1,
         lastRequestDate: serverTimestamp()
       });
       
       // Atualizar estado local
       setPendingAuthorization(true);
       setIsAuthorized(false);
       
       console.log(`Nova solicita√ß√£o de autoriza√ß√£o enviada para ${email}`);
     } catch (error) {
       console.error('Erro ao solicitar nova autoriza√ß√£o:', error);
       throw error;
     }
   };

   // Fun√ß√£o para excluir usu√°rio (apenas para administradores)
   const deleteUser = async (userId, targetUserEmail) => {
     try {
       // Verificar se o usu√°rio atual √© admin
       if (!isAdminEmail(userEmail)) {
         throw new Error('Apenas administradores podem excluir usu√°rios');
       }

       // Verificar se n√£o est√° tentando excluir outro admin
       if (isAdminEmail(targetUserEmail)) {
         throw new Error('N√£o √© poss√≠vel excluir um administrador');
       }

       // Excluir usu√°rio do Firestore
       await deleteDoc(doc(db, 'users', userId));
       
       toast.success('Usu√°rio exclu√≠do com sucesso!');
       return true;
     } catch (error) {
       console.error('Erro ao excluir usu√°rio:', error);
       toast.error(`Erro ao excluir usu√°rio: ${error.message}`);
       return false;
     }
   };

  // Observar mudan√ßas no estado de autentica√ß√£o
  useEffect(() => {
    // Verificar se o auth est√° configurado
    if (!auth) {
      console.error('Firebase Auth n√£o est√° configurado');
      setLoading(false);
      return;
    }

    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      setUser(user);
      setUserId(user?.uid || null);
      
      if (user) {
        const email = user.email;
        setUserEmail(email);
        
        // Verificar autoriza√ß√£o no Firestore
        const authStatus = await checkUserAuthorization(user.uid, email);
        setUserProfile(authStatus.profile);
        setPendingAuthorization(authStatus.pendingAuthorization);
        setIsAuthorized(authStatus.isAuthorized);
        
         if (!authStatus.isAuthorized && !authStatus.pendingAuthorization) {
           // Fazer logout se n√£o autorizado e n√£o pendente
           toast.error('‚ùå Acesso negado. Sua conta n√£o foi autorizada para acessar este sistema.');
           signOut(auth);
         }
      } else {
        setIsAuthorized(false);
        setUserEmail(null);
        setPendingAuthorization(false);
        setUserProfile(null);
      }
      
      setLoading(false);
    }, (error) => {
      console.error('Erro no AuthStateChanged:', error);
      setLoading(false);
    });

    return () => unsubscribe();
  }, []);

   // Listener em tempo real para mudan√ßas de autoriza√ß√£o
   useEffect(() => {
     if (!userId) return;

     let isSubscribed = true;
     const userDocRef = doc(db, 'users', userId);
     
     const unsubscribe = onSnapshot(userDocRef, (doc) => {
       if (!isSubscribed) return;
       
       if (doc.exists()) {
         const userData = doc.data();
         const wasAuthorized = isAuthorized;
         const wasPending = pendingAuthorization;
         
         // Atualizar estados
         setPendingAuthorization(userData.pendingAuthorization || false);
         setIsAuthorized(userData.isAuthorized || false);
         setUserProfile(userData);
         
         // Notificar mudan√ßas de status
         if (wasAuthorized && !userData.isAuthorized) {
           // Usu√°rio foi desautorizado!
           toast.error('‚ùå Sua conta foi desautorizada. Entre em contato com o administrador.');
           // Fazer logout ap√≥s um pequeno delay para mostrar a mensagem
           setTimeout(() => {
             signOut(auth);
           }, 2000);
         } else if (wasPending && userData.isAuthorized) {
           // Usu√°rio foi autorizado!
           toast.success('üéâ Parab√©ns! Sua conta foi autorizada. Voc√™ agora tem acesso ao sistema!');
         } else if (wasPending && !userData.pendingAuthorization && !userData.isAuthorized) {
           // Usu√°rio foi negado
           toast.error('‚ùå Sua solicita√ß√£o de acesso foi negada. Entre em contato com o administrador.');
           // Fazer logout ap√≥s um pequeno delay para mostrar a mensagem
           setTimeout(() => {
             signOut(auth);
           }, 2000);
         }
       }
     }, (error) => {
       if (isSubscribed) {
         console.error('Erro ao monitorar autoriza√ß√£o:', error);
       }
     });

     return () => {
       isSubscribed = false;
       unsubscribe();
     };
   }, [userId, isAuthorized, pendingAuthorization]);

   const value = {
     user,
     userId,
     loading,
     isAuthorized,
     userEmail,
     pendingAuthorization,
     userProfile,
     authMode,
     setAuthMode,
     loginWithGoogle,
     loginWithEmail,
     registerWithEmail,
     logout,
     authorizeUser,
     getAllUsers,
     getPendingUsers,
     getAuthorizedUsers,
     getUserProviders,
     getAllProviders,
     requestNewAuthorization,
     deleteUser
   };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
